Draw Call 
CPU가 GPU에게 어떤 그림을 그려달라고 요청하는 것
Draw Call 값이 낮을 수록 게임이 가벼움 -> 기기에 따라 특정 개수를 넘기면 프레임 드랍 현상
모바일의 경우 100 넘지 않는 것 권장

Batches
Draw Call을 포함하는 상위개념 (유니티 5.0 부터 Draw Call 대신 Batch 사용하여 "게임뷰-Stats" 에 렌더링 정보 표현)
Batches는 Mesh, Material, Shader, Draw Call 등의 정보를 종합적으로 계산
-> Batches 값이 낮을 수록 게임 최적화가 좋다

Batches 를 낮추는 방법 중 하나가 바로 Sprite Atlas 기법을 사용하는 것

***
Sprite Atlas : 여러 장의 스프라이트 이미지를 한 장의 텍스처(이미지 파일)에 모아 두고 필요한 부분만 사용하는 것
유니티는 Sprite Packer(레거시)와 Sprite Atlas 기능을 제공한다

사용 이유)
2D 게임에서 배경, 캐릭터, 적 등 표현 시 이미지 에셋 사용
매 렌더링 시마다 각 이미지 에셋 별로 1 Batches 증가
ex1) 캐릭터, 적, 아이템 등 모두 다른 이미지를 사용하는 오브젝트 100개가 동시에 씬에 등장 시 Batches=100
ex2) 동일한 이미지를 사용하는 오브젝트 100개 시 Batches=1
-> Sprite Atlas를 사용해 서로 다른 이미지를 하나의 텍스처에 모아두고 사용하면 서로 다른 이미지의 오브젝트를 100개 만들어도 Batches=1

***
프로젝트뷰에서 Sprite Atlas 생성
(Atlas의 타입은 Master과 Variant로 나뉨, Variant는 Master Sprite Atlas를 등록하여 HD/SD 모드 등으로 설정하여 활용할 수 있음) << 모르겠다
Objects for Packing에 묶을 이미지들 추가 후 Pack Preview 누르기

Atlas 내 하나의 이미지만 사용해도 Atlas 통째로 load 하므로 한 씬 단위 또는 한 오브젝트 가 사용하는 이미지 단위로 Atlas 로 묶어주는 게 좋다

***이미지(텍스쳐 에셋)의 인스펙터 뷰
텍스쳐 타입 : 텍스쳐의 사용 용도에 따라 설정 
	default : 일반적인 3D 오브젝트의 material 적용 시 설정
	sprite(2d and ui) : 2D 스프라이트 오브젝트나 UI에 텍스처 적용 시 설정

스프라이트 모드(타입이 스프라이트 2D and UI 일 때 표시)
	single : 단일 이미지 전체를 사용
	multi : 개발자가 원하는 형태로 이미지를 분할하여 사용
	polygon : 도형 형태(외부 이미지 사용시에는 보통 사용하지 않는다, 새 오브젝트 추가 시 보여지는 도형들의 텍스쳐가 Polygon)

Pixels per Unit : 몇 픽셀을 Unity Scale 1로 설정할 것인지

pivot : 텍스쳐의 중심 축

Sprite Editor 버튼 누르면 스프라이트에디터 뷰 띄워진다
	Sprite Mode(싱글, 멀티, 폴리곤)에 따라 옵션 차이
	스프라이트의 위치, 크기, 경계, 중심점 편집 가능
	sprite 분할, 폴리곤 점 개수 수정 등의 편집 가능

	멀티 시 이미지 분할 가능
	드래그로 분할 영역 생성 가능
	일정한 규칙으로 분할 시 slice 메뉴 사용
		automatic 텍스처를 자동으로 분할
		grid by cell size 설정한 셀 사이즈로 분할
		grid by cell count 설정한 가로 세로 수(행, 열) 로 분할

* 하나의 이미지를 분할하여 사용하는 이유 ~ 이미지 분할과 POT(power of two) 규격
- 게임 텍스처 제작시 POT 규격으로 제작해야 함 (POT : 텍스처의 가로/사로 사이즈가 2의 제곱)
- POT 규격이 아닌 텍스처는 POT 규격으로 변환 위해 내부적인 처리 거치게 됨 -> 메모리 비용 증가
- 게임에서 사용되는 이미지는 POT 규격으로 제작될 수 없기 때문에 하나의 POT 규격 텍스처에 여러장의 이미지(보통 같은 성격을 가진)를 넣어 제작
ex1) 31*31 픽셀의 이미지는 32*32 의 POT 크기의 메모리 공간에 저장
ex2) 33*33 픽셀의 이미지는 64*64 크기의 메모리에 저장 -> 낭비 공간 크다 -> 빈 공간에 여러장의 이미지 저장(캐릭터 이동 애니메이션 등)

* 기본 도형들은 따로 준비하지 않아도 프로젝트메뉴 - 2D - 스프라이트 에서 만들 수 있다
폴리곤모드는 change shape 값으로 다각형 설정 가능 3~128 (삼각형 ~ 원)

***
스프라이트 애니메이션 = 오브젝트의 스프라이트 렌더러 컴포넌트에서 이미지를 주기적으로 교체하는 것
1) 애니메이터 컴포넌트 : 게임 오브젝트가 애니메이션 사용하기 위해 필요한 컴포넌트

2) 애니메이터 컨트롤러 에셋 : 애니메이션 에셋들을 관리하는 파일, 하나의 오브젝트에서 사용되는 애니메이션들을 묶어서 관리
	프로젝트뷰 - + - 애니메이터 컨트롤러로 생성
	애니메이터 뷰를 열어 설정 가능
		Any State : 모든 상태에서 접근 가능한 상태 (하늘색)
		Entry : Sub State Machine 사용 시 외부에서  Sub State Machine 으로 들어오는 상태 (연두색)
		Exit :  Sub State Machine 사용 시 외부로 나가는 상태 (빨간색)
		기본 애니메이션 상태 : 주황색으로 표시, 오브젝트가 애니메이션 재생이 가능한 상태일 때 제일 먼저 실행되는 애니메이션
		나머지 애니메이션들은 코드를 이용해 재생을 제어 (회색)
		
	애니메이터 컴포넌트의 컨트롤러 변수에 등록
	
	애니메이터 뷰에서 애니메이터 컨트롤러 에셋 설정

3) 애니메이션 에셋 : "이동", "대기" 등과 같이 하나의 애니메이션을 동작을 파일로 저장한 것
	프로젝트뷰 - + - 애니메이션으로 생성 (애니메이션 컨트롤러 에셋에 등록 가능)
	애니메이션 뷰에서 애니메이션 에셋 설정 가능
		하나의 애니메이션으로 설정할 텍스쳐들 등록
		재생속도 설정
		이벤트 함수 등록(특정 프레임에서 함수 호출)
	

즉, 애니메이션 재생이 필요한 오브젝트에

1) 애니메이터 컴포넌트 추가
2) 애니메이터 컴포넌트의 컨트롤러 변수에 애니메이터 컨트롤러 에셋을 등록

하여 애니메이션을 재생한다.

*** 방법
1. 게임오브젝트 생성
2. 애니메이션으로 쓸 이미지들의 모드를 multiple로 설정 후 slice (애니메이션이 하나의 이미지로 합쳐진 상태이므로 잘라내기)
3. 게임오브젝트의 스프라이트에 잘라낸 이미지의 0번 삽입
4. 게임오브젝트에 애니메이터 컴포넌트 추가
5. 프로젝트뷰에서 애니메이터 컨트롤러 생성, 애니메이터 컴포넌트에 등록
6. 프로젝트뷰에서 애니메이션 에셋 생성, Loop Time으로 반복 여부 설정 가능(체크x 시 1회만 재생)
7. 애니메이터 컨트롤러의 애니메이터뷰에서 애니메이션 등록 가능
	애니메이터뷰, 애니메이션뷰의 내용을 수정할 때는 프로젝트뷰에 있는 애니메이터 컨트롤러, 애니메이션 에셋을 선택(인스펙터뷰에 나오는 게 선택된 상태)하는 것이 아니라 (계층뷰에서) 그 에셋들이 등록되어 있는 게임오브젝트, 프리팹을 선택해야 한다.
	애니메이터뷰에서 6번에서 생성한 애니메이션 드래그하여 추가
8. 애니메이션뷰애 2번에서 자른 이미지들 배치(01210), 재생해보면 매우 빠르므로 재생 속도(Samples=2D 애니메이션 재생 속도) 조절(시간축 ... 누르면 Show Sample Rate 옵션, 기본 60, 수치 높을수록 재생이 빠르다)

9. 다른 애니메이션 추가 위해 slice, 애니메이션 에셋 생성(사망은 1회만 재생되므로 Loop Time 체크x)
10. 애니메이터 컨트롤러에 사망애니메이션 추가
11. 사망 애니메이션에 이미지들 추가

12. 사망 애니메이션 추가되었으나 현재 상태에서는 아이들 애니메이션만 재생 -> 상태 전이 추가 필요 
	애니메이터뷰에서 아이들 애니메이션 우클릭 -> Make Transition 하여 사망 애니메이션에 잇기
	Make Transition은 조건이 없을 경우 1회 재생 후 다음 애니메이션으로 넘어간다

13. 트랜지션에 조건주기
	트랜지션의 컨디션에 조건 추가하여 원하는 시점에 상태 전이 가능
	상황에 맞게 파라미터(float, int, bool, trigger) 생성
	트리거 파라미터는 공격, 피격, 사망과 같이 단발적으로 호출되는 애니메이션에 주로 사용
	
	좌상단 레이어 옆에 파라미터 누르고 IsDie 트리거 파라미터 생성, 트랜지션 누르고 컨디션에 등록 (재생 후 트리거 체크 시 사망 모션 확인 가능)
	트랜지션의 Has Exit Time 옵션 : 현재 상태 전이 조건 만족 시 바로 동작을 변경할 지, 해당 동작 끝까지 재생하고 전이할 지 결정
	(true 시 해당 애니메이션 재생 완료 후 상태 전이)

14. 코드로 애니메이션 전환

    private Animator animator;
    private void Awake()
    {
        animator = GetComponent<Animator>();
    }

    private void Update()
    {
        if (Input.GetKeyDown(KeyCode.Space))
            animator.SetTrigger("isDie");
    }

애니메이션이 적용된 게임오브젝트에 적용시켜 스페이스 누르면 트리거 작동되어 애니메이션 전환 
파라미터 값 설정 함수
name = 파라미터 이름
animator.SetBool(string name, bool value);
animator.SetFloat(string name, float value);
animator.SetInteger(string name, int value);
animator.SetTrigger(string name);

파라미터 값 참조 함수
bool value = animator.GetBool(string name);
float value = animator.GetFloat(string name);
int value = animator. GetInt(string name);

15. 애니메이션 재생 중 함수 호출도 가능

    public void OnDieEvent()
    {
        Debug.Log("End of Die Animation");
    }

재생할 함수는 public으로 작성되어야 함
애니메이션뷰에서 add event 후 재생할 함수 이름 작성

